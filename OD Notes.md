# OD Notes

### 前置知识：

#### 32位寄存器：

- ESP：指向堆栈最顶端的**地址**

- EIP：指向当前将要执行的指令

- EAX：例如EAX = 12345678，那么AX（16位寄存器）是EAX后4位5678，它还分为AH（前两位56）和AL（后两位），同理其它寄存器都可以如此分割
- ECX：计数器

#### 标志寄存器：

- O（溢出标志）：在改变符号位，返回错误值时被设置

- A（辅助进位标志）：

- P（奇偶标志）：指令结果的二进制格式有偶数个1时，被设置

- Z（零标志）：运算结果产生0时被设置

- S（符号标志）：结果为负时被设置，也用来比较第一个操作数是否大于第二个操作数

- C（进位标志）：（无符号运算的结果）在超过最大数值时设置，可能是寄存器的值

- T：

- D：


#### 汇编指令：

- NOP：无操作
- PUSH：将操作数压入堆栈

###### Tips：push[401008]时将401008内存单元中的内容 ***倒序*** 压入堆栈，而push 401008是把401008这个数值压入堆栈

- POP：取出堆栈顶部的第一个字母或第一个值，然后存到目标地址内存单元中

- PUSHAD：把寄存器窗口的EAX到EDI依次压入到堆栈中

- POPAD：与PUSHAD操作相反。另外，PUSHA,POPA和PUSHAD,POPAD在16位程序中使用，不做研究

- MOV：将第二个操作数赋值给第一个操作数


###### Tips：移动4个字节使用DWORD,移动2个字节使用WORD，移动1个字节使用BYTE

- MOVSX (带符号扩展的传送指令)：第二个操作数可能一个寄存器也可能是内存单元,第一个操作数的位数比第二个操作数多,第二个操作数的符号位填充第一个操作数剩余部分


正负：16位数的范围是0000到FFFF。0000到7FFF是正数,8000到FFFF是负数

- MOVZX (带0扩展的传送指令)：MOVZX类似于前面的语句,但是这种情况下,剩余的部分不根据第二个操作数的正负来进行填充，而是填充为0

- INC：对寄存器或地址加一
- DEC：对寄存器或地址减一

------

- ADD：ADD指令有两个操作数,相加后的结果存放到第一个操作数中
- ADC(带进位的加法)：
- 两个操作数的和加上进位标志的值,结果存放到第一个操作数中
- SUB：将第一个操作数减去第二个操作数的值存放到第一个操作数中
- SBB：计算两个操作数的差值,并且还要减去进位标志,结果存放到第一个操作数中

- MUL：只有一个操作数,另一个操作数是EAX,结果存放到EDX:EAX中

- IMUL(有符号数的乘法)：与MUL不同的是，IMUL允许有多个操作数。

3.第一个操作数,用来乘以两个数,并且保存相乘的结果,结果必须保存在寄存器中。

2.只有两个操作数,两者相乘,并将结果存放到第一个操作数中。

1.结果存放到EDX:EAX中,这意味着拥有两倍的大小,通过两个操作数或者三个操作数无法完成的操作可以通过一个操作数的方式来完成。

- DIV(无符号除法)/IDIV(有符号除法)：这两个指令反别与MUL和IMUL相反。IDIV指令经常被使用。如果是一个操作数的话,那么它和DIV类似,只不过操作数是有符号的,结果依然保存在EDX:EAX中。两个操作数的情况,第一个操作数除以第二个操作数，结果存放到第一个操作数中。三个操作数的情况,第二个操作数除以第三个操作数,结果存放到第一个操作数中。

- XADD(交换并相加)

- NEG：取反

  ------

- AND

- OR

- XOR：对destination和source异或运算，结果存在destination中。语法：xor destination,source

- NOT

  ------

- CMP：通常情况下，比较指令有两个操作数，并根据比较的结果来决定程序是否跳转到后面的分支中。第一个大于第二个S置1，相等则Z置1，小于则C置1

- TEST(逻辑比较)：AND。可以测eax是否等于0

- JMP – 跳转

- JE, JZ – 结果为零则跳转

- JNE, JNZ – 结果不为零则跳转 （0标志位为0时则跳转）

- JS – 结果为负则跳转

- JNS – 结果不为负则跳转

- JP, JPE – 结果中1的个数为偶数则跳转

- JNP, JNPE – 结果为1的个数为奇数则跳转

- JO – 结果溢出了则跳转

- JNO – 结果没有溢出则跳转

- JB, JNAE – 小于则跳转 ，(无符号数)，即C标志位置1的情况

- JNB, JAE – 大于等于则跳转 (无符号数)

- JBE, JNA – 小于等于则跳转 (无符号数)

- JNBE, JA – 大于则跳转(无符号数)

- JL, JNGE –  小于则跳转 (有符号数)

- JNL, JGE – 大于等于则跳转 (有符号数)

- JLE, JNG – 小于等于则跳转 (有符号数)

- JNLE, JG – 大于则跳转(有符号数)

------

- call：转移到指定的子程序处,它的操作数就是给定的地址
- retn：子程序返回、转移到某地址与jmp类似
- retn 0x10：返回以后,返回地址从堆栈中删除。堆栈指针向下移动4字节(更确切的说是向高地址一侧)。对于RET 10H来说,除了完成RET的操作之外,ESP还要增加10h。所以,ESP的增量为10h + 4h = 14h = 20
- 嵌套调用：当一个子程序调用了另一个子程序的时候,通过的这个子程序也可以去调用别的子程序
- Loop：将计数器ECX的值减1,判断ECX的值是否为0,如果为0就跳转到指定的地址
- Loopz，Loope：重复循环,直到零标志位Z置1。此外,LOOPZ,LOOPNZ指令还将检查零标志位Z是否为0。只有计数器的值和零标志Z同时满足条件时才循环。
- Loopnz，Loopne：重复循环,直到零标志位Z清0

------

- movs：从一个地址向另一个地址复制数据。源地址保存在ESI寄存器中,目的地址保存在EDI寄存器。另外一种书写形式为:MOVSD。与之对应的还有拷贝两个字节的MOVSW指令和拷贝一个字节的MOVSB指令
- movzx：其实就是将我们的源操作数取出来,然后置于目的操作数,目的操作数其余位用0填充。

###### Tips： cld 设置**方向标志位DF**为0, 每次复制完, esi, edi自动增加, 指向下一个地址. std 设置**方向**标志位**DF**为1, 每次复制完, esi, edi自动减少, 指向下一个地址.

- rep：该前缀表示当前指令需要执行的次数ECX。每次循环计数器ECX的值递减1

- LODS/LODSW/LODSB：该指令从源地址(像之前一样,ESI)拷贝数据到EAX中。

- STOS：该指令是将EAX的值拷贝到EDI指向的内存单元中

- CMPS：该指令比较ESI和EDI指向内存单元的内容，可以配合REPE/REPZ前缀指令使用,直到计数器ECX的值为0或者零标志位清0


-----

###### Tips：使用间接寻址的指令,只能在执行这条指令的时候获取地址当前的值。

------

- cdq： 这个指令把 EAX 的第 31 bit 复制到 EDX 的每一个 bit 上。 它大多出现在除法运算之前。它实际的作用只是把EDX的所有位都设成EAX最高位的值。也就是说，当EAX <80000000, EDX 为00000000；当EAX >= 80000000， EDX 则为FFFFFFFF。

------

#### 断点：

- 普通断点：当我们设置断点后,OD会将对应指令处第一个字节指令替换成CC。但是为了不影响界面显示效果,OD会将CC显示为原字节。但是,我们可以在内存单元中读取出其真实的内容,并且可以在反调试中用此方法来检测断点。
- 内存访问断点：有两个缺点:1.它们不会出现[B]断点列表中和其他的地址。所以,你必须记得设置在什么地址处。2.不能同时设置多个内存断点。如果你设置了一个那么你之前设置的就会被自动删除。当我们对指定内存单元没有写权限,尝试写入的时候会触发异常,OD会拦截到这个异常,并中断下来,我们看到断下来的时候,OD已经将内存页的访问属性设置正常了
- 在同一个API函数中,如果通过bp命令设置断点会被程序检测而导致断点失效的话,也许设置内存访问断点可以绕过这个检测。设置内存访问断点这个方法也可以通过检测内存页的属性并恢复内存页的属性来进行保护,但是这在反调试技巧中并不常见。
- 硬件断点：OD中最多设置四个。单个硬件写入断点或者硬件访问断点可以设置1,2或者4个字节的长度,不论我们选择的数据范围有多大,只有前4个字节会起作用。硬件访问/写入断点是断在触发硬件断点的下一条指令处。
- 条件记录断点：我们可以通过设置该断点来记录下设置的条件的精确值。我们给一个API函数设置条件记录断点,程序中有很多地方调用了这个API函数,通过该条件记录断点我们可以精确的记录程序中每处调用该API函数传递给它的内容。
- 消息断点：如果应用程序并不是通过API函数来获取用户输入的序列号的话,我们可以通过消息断点来定位,这是消息断点的优点。另外，消息断点与普通CC断点的区别在于,普通CC断点在程序启动之前就可以设置,但是对于消息断点来说,只有在窗口创建之后才能够设置消息断点以及拦截消息。

------

## 方法：

### 0x00爆破

改汇编代码，发布补丁

### 0x01硬编码序列号

正确的序列号是作为全局字符串出现在程序中的

需要注意一下两点：

1. 成千上万行的程序无法肉眼直接看出序列号
2. 看到的序列号不一定为真，需检验其正确性































































































































###### 参考文献：

看雪论坛：《使用OD从零开始Cracking》

