# OD Notes

### 前置知识：

#### 32位寄存器：

- ESP：指向堆栈最顶端的**地址**

- EIP：指向当前将要执行的指令

- EAX：例如EAX = 12345678，那么AX（16位寄存器）是EAX后4位5678，它还分为AH（前两位56）和AL（后两位），同理其它寄存器都可以如此分割
- ECX：计数器

#### 标志寄存器：

- O（溢出标志）：在改变符号位，返回错误值时被设置

- A（辅助进位标志）：

- P（奇偶标志）：指令结果的二进制格式有偶数个1时，被设置

- Z（零标志）：运算结果产生0时被设置

- S（符号标志）：结果为负时被设置，也用来比较第一个操作数是否大于第二个操作数

- C（进位标志）：（无符号运算的结果）在超过最大数值时设置，可能是寄存器的值

- T：

- D：


#### 汇编指令：

- NOP：无操作
- PUSH：将操作数压入堆栈

###### Tips：push[401008]时将401008内存单元中的内容 ***倒序*** 压入堆栈，而push 401008是把401008这个数值压入堆栈

- POP：取出堆栈顶部的第一个字母或第一个值，然后存到目标地址内存单元中

- PUSHAD：把寄存器窗口的EAX到EDI依次压入到堆栈中

- POPAD：与PUSHAD操作相反。另外，PUSHA,POPA和PUSHAD,POPAD在16位程序中使用，不做研究

- MOV：将第二个操作数赋值给第一个操作数


###### Tips：移动4个字节使用DWORD,移动2个字节使用WORD，移动1个字节使用BYTE

- MOVSX (带符号扩展的传送指令)：第二个操作数可能一个寄存器也可能是内存单元,第一个操作数的位数比第二个操作数多,第二个操作数的符号位填充第一个操作数剩余部分


正负：16位数的范围是0000到FFFF。0000到7FFF是正数,8000到FFFF是负数

- MOVZX (带0扩展的传送指令)：MOVZX类似于前面的语句,但是这种情况下,剩余的部分不根据第二个操作数的正负来进行填充，而是填充为0

- INC：对寄存器或地址加一
- DEC：对寄存器或地址减一

------

- ADD：ADD指令有两个操作数,相加后的结果存放到第一个操作数中
- ADC(带进位的加法)：
- 两个操作数的和加上进位标志的值,结果存放到第一个操作数中
- SUB：将第一个操作数减去第二个操作数的值存放到第一个操作数中
- SBB：计算两个操作数的差值,并且还要减去进位标志,结果存放到第一个操作数中

- MUL：只有一个操作数,另一个操作数是EAX,结果存放到EDX:EAX中

- IMUL(有符号数的乘法)：与MUL不同的是，IMUL允许有多个操作数。

3.第一个操作数,用来乘以两个数,并且保存相乘的结果,结果必须保存在寄存器中。

2.只有两个操作数,两者相乘,并将结果存放到第一个操作数中。

1.结果存放到EDX:EAX中,这意味着拥有两倍的大小,通过两个操作数或者三个操作数无法完成的操作可以通过一个操作数的方式来完成。

- DIV(无符号除法)/IDIV(有符号除法)：这两个指令反别与MUL和IMUL相反。IDIV指令经常被使用。如果是一个操作数的话,那么它和DIV类似,只不过操作数是有符号的,结果依然保存在EDX:EAX中。两个操作数的情况,第一个操作数除以第二个操作数，结果存放到第一个操作数中。三个操作数的情况,第二个操作数除以第三个操作数,结果存放到第一个操作数中。

- XADD(交换并相加)

- NEG：取反

  ------

- AND

- OR

- XOR：对destination和source异或运算，结果存在destination中。语法：xor destination,source

- NOT

  ------

- CMP：通常情况下，比较指令有两个操作数，并根据比较的结果来决定程序是否跳转到后面的分支中。第一个大于第二个S置1，相等则Z置1，小于则C置1

- TEST(逻辑比较)：AND。可以测eax是否等于0

- JMP – 跳转

- JE, JZ – 结果为零则跳转

- JNE, JNZ – 结果不为零则跳转 （0标志位为0时则跳转）

- JS – 结果为负则跳转

- JNS – 结果不为负则跳转

- JP, JPE – 结果中1的个数为偶数则跳转

- JNP, JNPE – 结果为1的个数为奇数则跳转

- JO – 结果溢出了则跳转

- JNO – 结果没有溢出则跳转

- JB, JNAE – 小于则跳转 ，(无符号数)，即C标志位置1的情况

- JNB, JAE – 大于等于则跳转 (无符号数)

- JBE, JNA – 小于等于则跳转 (无符号数)

- JNBE, JA – 大于则跳转(无符号数)

- JL, JNGE –  小于则跳转 (有符号数)

- JNL, JGE – 大于等于则跳转 (有符号数)

- JLE, JNG – 小于等于则跳转 (有符号数)

- JNLE, JG – 大于则跳转(有符号数)

------

- call：转移到指定的子程序处,它的操作数就是给定的地址
- retn：子程序返回、转移到某地址与jmp类似
- retn 0x10：返回以后,返回地址从堆栈中删除。堆栈指针向下移动4字节(更确切的说是向高地址一侧)。对于RET 10H来说,除了完成RET的操作之外,ESP还要增加10h。所以,ESP的增量为10h + 4h = 14h = 20
- 嵌套调用：当一个子程序调用了另一个子程序的时候,通过的这个子程序也可以去调用别的子程序
- Loop：将计数器ECX的值减1,判断ECX的值是否为0,如果为0就跳转到指定的地址
- Loopz，Loope：重复循环,直到零标志位Z置1。此外,LOOPZ,LOOPNZ指令还将检查零标志位Z是否为0。只有计数器的值和零标志Z同时满足条件时才循环。
- Loopnz，Loopne：重复循环,直到零标志位Z清0

------

- movs：从一个地址向另一个地址复制数据。源地址保存在ESI寄存器中,目的地址保存在EDI寄存器。另外一种书写形式为:MOVSD。与之对应的还有拷贝两个字节的MOVSW指令和拷贝一个字节的MOVSB指令
- movzx：其实就是将我们的源操作数取出来,然后置于目的操作数,目的操作数其余位用0填充。

###### Tips： cld 设置**方向标志位DF**为0, 每次复制完, esi, edi自动增加, 指向下一个地址. std 设置**方向**标志位**DF**为1, 每次复制完, esi, edi自动减少, 指向下一个地址.

- rep：该前缀表示当前指令需要执行的次数ECX。每次循环计数器ECX的值递减1

- LODS/LODSW/LODSB：该指令从源地址(像之前一样,ESI)拷贝数据到EAX中。

- STOS：该指令是将EAX的值拷贝到EDI指向的内存单元中

- CMPS：该指令比较ESI和EDI指向内存单元的内容，可以配合REPE/REPZ前缀指令使用,直到计数器ECX的值为0或者零标志位清0


-----

###### Tips：使用间接寻址的指令,只能在执行这条指令的时候获取地址当前的值。

------

- cdq： 这个指令把 EAX 的第 31 bit 复制到 EDX 的每一个 bit 上。 它大多出现在除法运算之前。它实际的作用只是把EDX的所有位都设成EAX最高位的值。也就是说，当EAX <80000000, EDX 为00000000；当EAX >= 80000000， EDX 则为FFFFFFFF。

------

#### 断点：

- 普通断点：当我们设置断点后,OD会将对应指令处第一个字节指令替换成CC。但是为了不影响界面显示效果,OD会将CC显示为原字节。但是,我们可以在内存单元中读取出其真实的内容,并且可以在反调试中用此方法来检测断点。
- 内存访问断点：有两个缺点:1.它们不会出现[B]断点列表中和其他的地址。所以,你必须记得设置在什么地址处。2.不能同时设置多个内存断点。如果你设置了一个那么你之前设置的就会被自动删除。当我们对指定内存单元没有写权限,尝试写入的时候会触发异常,OD会拦截到这个异常,并中断下来,我们看到断下来的时候,OD已经将内存页的访问属性设置正常了
- 在同一个API函数中,如果通过bp命令设置断点会被程序检测而导致断点失效的话,也许设置内存访问断点可以绕过这个检测。设置内存访问断点这个方法也可以通过检测内存页的属性并恢复内存页的属性来进行保护,但是这在反调试技巧中并不常见。
- 硬件断点：OD中最多设置四个。单个硬件写入断点或者硬件访问断点可以设置1,2或者4个字节的长度,不论我们选择的数据范围有多大,只有前4个字节会起作用。硬件访问/写入断点是断在触发硬件断点的下一条指令处。
- 条件记录断点：我们可以通过设置该断点来记录下设置的条件的精确值。我们给一个API函数设置条件记录断点,程序中有很多地方调用了这个API函数,通过该条件记录断点我们可以精确的记录程序中每处调用该API函数传递给它的内容。
- 消息断点：如果应用程序并不是通过API函数来获取用户输入的序列号的话,我们可以通过消息断点来定位,这是消息断点的优点。另外，消息断点与普通CC断点的区别在于,普通CC断点在程序启动之前就可以设置,但是对于消息断点来说,只有在窗口创建之后才能够设置消息断点以及拦截消息。

------

## 方法：

### 0x00爆破

改汇编代码，发布补丁

### 0x01硬编码序列号

正确的序列号是作为全局字符串出现在程序中的

需要注意一下两点：

1. 成千上万行的程序无法肉眼直接看出序列号
2. 看到的序列号不一定为真，需检验其正确性

## 脱壳：

我们知道当到达OEP后,各个区段在内存中的分布跟原始程序很接近,这个时候我们就可以尝试将其转储到(dump)文件中,完成程序的重建工作(PS:脱壳)。

通常脱壳的基本步骤如下:

### 1:寻找OEP

#### 1)搜索**JMP**或者**CALL**指令的**机器码**(即一步直达法,只适用于少数壳,包括UPX,ASPACK壳)

原理：一般情况下(理想情况)壳在解密完原程序各个区段以后,需要一个长JMP或者CALL跳转到原程序代码段中的OEP处开始执行原程序代码。

应用：在OD中右键选择Searchfor-ALL Commands，然后对各指令下断

适用范围：简单壳

#### 2)SFX法

应用：Trace real entry blockwise[inaccurate]速度快；Trace real entry blockwise[very slow]速度慢，精确

适用性：入口点位于代码段之外的程序（常见）

#### 3)使用Patch过的OD来定位OEP(即内存映像法)

原理：正常的内存访问断点**读取,写入,执行**的时候都会断下来,该Patch过的OD内存访问断点仅当**执行**的时候才会断下来，因此可以利用这一点来定位OEP

例：

![image-20251126172501004](OD Notes.assets/image-20251126172501004.png)

在第一个区段设置内存访问断点，只有程序执行到内存访问断点才会中断，那么就可以找到OEP。如果第一个区段不行，那么就继续给后面的区段设置断点，直到找到OEP

![image-20251126173348095](OD Notes.assets/image-20251126173348095.png)

这个例子中，在idata区段设置内存访问断点程序并没有中断，而在text区段设置内存访问断点后程序中断下来

ps：需要研究一下xdbg能不能用到这种方法

#### 4)堆栈平衡法(即ESP定律法)

原理：在解密完区段,跳往OEP之前会恢复寄存器环境，在这是给堆栈顶部的数据设置内存/硬件访问断点就可以定位到OEP附近

应用：找到PUSHAD或PUSH AEX、PUSH EBX等指令。F7单步执行指令，各寄存器的值被压入堆栈，然后对这些初始值(ESP)设置断点。程序试图读取这些值的时候就会断下来，位置在OEP附近。

适用范围：古老的壳

#### 5)VB应用程序定位OEP

#### 6)最后一次异常法

原理：在解密期间程序产生诸多异常，最后一次异常离OEP最近，因此可以定位OEP

应用：先跑起来，在日志里找到位于程序所在区段的最后一次异常，记住这个地址。再跑一次，忽略所有异常，直到停在相应地址。后面，对代码段设置内存访问断点，跑起来后，程序中断在OEP。

壳对内存访问断点的检测：

- 如果我们在离OEP越近的地方设置内存访问断点,就越不容易被壳检测到。

- 为什么不在一开始设置内存访问断点呢?原因是很多壳会检测程序在开始时是否自身被设置内存访问断点,如果执行到了最后一次异常处的话,很可能已经绕过了壳的检测时机

适用范围：解密时产生大量异常的程序

#### 7)利用壳最常用的API函数来定位OEP

比如：GetProcAddress，LoadLibrary，ExitThread......

应用：给GetProcAddress设置条件记录断点，先拿到日志，获取函数返回地址，中断条件：[ESP] == 47009A，最终会断在OEP附近。

适用范围：大多数

#### 8)利用应用程序调用的第一个API函数来定位OEP

直接给应用程序调用的第一个API函数设置断点，对VC++来说第一个API是GetVersion,GetModuleHandleA，断下来后跟进它的返回地址，就会定位到OEP附近。

### 2:转储(PS:传说中的dump)

### 3:修复IAT(修复导入表)

#### 什么是IAT表：

为了解决不同系统上dll版本不同问题，操作系统提供了IAT表确保程序在不同版本的dll下也能正常运行。程序在不同版本操作系统上都是调用间接跳转到IAT表中,在IAT中读取到真正的API函数入口地址,然后调用之

#### 如何定位IAT：

1以MessageBoxA为例，找到主模块中对它的调用，enter跟进，会看到一堆间接跳转。

![image-20251201194224576](OD Notes.assets/image-20251201194224576.png

![image-20251201194555568](OD Notes.assets/image-20251201194555568.png)

在数据窗口跟随这个跳转，则会看到4013AC这个地址保存了MessageBoxA的地址。类似的，可以看到其他区域也保存了其他函数的地址，那么这个地方就是IAT表。

##### 2IAT填充过程

找到PE文件头下的Import Table Address项

![image-20251201213728520](OD Notes.assets/image-20251201213728520.png)

偏移量是3000，在数据窗口中定位到**403000**

![image-20251201213828993](OD Notes.assets/image-20251201213828993.png)

选中的五个DWORD叫IMAGE_IMPORT_DESCRIPTOR，它具有如下结构：

OriginalFirstThunk

TimeDateStamp           时间戳

ForwarderChain           链表的前一个结构

Name1                   		指向DLL名称的指针

**FirstThunk**               	  指向的链表定义了针对Name1这个动态链接库引入的所有导入函数

关键在于Name1和FirstThunk字段，上图中，Name1对应地址是3290，对应403290处是user32.dll，所以FirstThunk自然对应的是user32的IAT起始地址

![image-20251201214504403](OD Notes.assets/image-20251201214504403.png)

![image-20251201214549503](OD Notes.assets/image-20251201214549503.png)

以此类推，后面紧跟的IID则是关于kernel32.dll的。

此外我们根据user32对应IAT表的起始地址773C2410，在可执行文件中定位到相关API的偏移量是32CC

![image-20251201215201026](OD Notes.assets/image-20251201215201026.png)

据此定位到4032CC，发现是KillTimer函数

![image-20251201215336632](OD Notes.assets/image-20251201215336632.png)

然后系统通过调用GetProcAddress函数获取KillTimer地址773C2410，该地址被填入到403184地址处（见上文）。

再读取IAT的第二个元素773B4FC0

![image-20251201220532380](OD Notes.assets/image-20251201220532380.png)

接着定位到可执行文件的偏移处，是32D8，

![image-20251201220852778](OD Notes.assets/image-20251201220852778.png)

对应的是GetSystemMetrics，定位到它的名称，再次获取它的基址填入到IAT。

![image-20251201220949731](OD Notes.assets/image-20251201220949731.png)

以此类推，直到程序获取完user32.dll的其他API地址遇到IAT为0的项，也就是黄框所示

![image-20251201221322878](OD Notes.assets/image-20251201221322878.png)

之后程序再找导入表的下一个IID，就是kernel32的IID，后面的步骤与上文类似，不再赘述。

![image-20251201221504678](OD Notes.assets/image-20251201221504678.png)

这就是IAT的填充过程

#### 对填充过程的简单总结

在可执行文件中查看这个地址，

![image-20251201203431150](OD Notes.assets/image-20251201203431150.png)保存的是3360，这是一个RVA（相对虚拟地址)，操作系统可以根据这个**指针**,定位（RVA+映像基址)到相应的API**函数名称**,然后通过调用GetProcAddress获取对应API函数的**地址**,然后将该地址填充到IAT中,覆盖原来的3360。

##### 为了确保操作系统将正确的API函数地址填充到IAT中,应该满足一下几点要求:

1:可执行文件各IAT项所在的文件偏移处必须是一个指针,指向一个字符串。

2:该字符串为API函数的名称。

#### 为什么要修复IAT

因为壳将IAT函数名称对应的字符串加密，存到某个不易被发现的地址处。程序运行的时候会先执行解密流程，读取IAT中所需要的API的名称指针,然后定位到API函数地址（GetProcAddress）,将其填入到IAT中,这个时候,IAT中已经被填充了正确的API函数地址,对应的API函数名称的字符串已经不需要了,可以清除掉。

#### IAT重定向





### 4:检查目标程序是否存在AntiDump等阻止程序被转储的保护措施,并尝试修复这些问题。

















### 调用约定

在 64 位 Windows 程序中，函数的前 4 个整数/指针参数**不是**压入堆栈的，而是依次存放在寄存器中：

- 第 1 个参数 -> **RCX**
- 第 2 个参数 -> **RDX**
- 第 3 个参数 -> **R8**
- 第 4 个参数 -> **R9**

例：

对于ws2_32.dll中的connect函数

```c
int connect(

 SOCKET     s,    // 第1个参数 (RCX): Socket句柄 (我们不关心)

 const sockaddr *name,  // 第2个参数 (RDX): 指向地址结构体的指针 (关键！)

 int       namelen  // 第3个参数 (R8):  结构体长度

);
```

第二个参数是指向地址结构体的指针，其中包含了ip和port，而它被存放在rdx寄存器中

![image-20251217112458380](OD Notes.assets/image-20251217112458380.png)

在内存窗口转到该地址，可以看到如图所示数据，前两个字节表示IPv4协议，后面两个字节是端口号，再后面四个字节是ip地址















































































































###### 参考文献：

看雪论坛：《使用OD从零开始Cracking》

